# coding: utf-8

"""
    Open Data Hub Tourism Api

    Open Data Hub Tourism Api based on .Net Core with PostgreSQL

    The version of the OpenAPI document: v1
    Contact: help@opendatahub.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json




from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_server.models.real_time_measurements import RealTimeMeasurements
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class WeatherRealTime(BaseModel):
    """
    WeatherRealTime
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, alias="Id")
    altitude: Optional[Union[StrictFloat, StrictInt]] = None
    category_id: Optional[StrictInt] = Field(default=None, description="Indicates whether the weather stations are: [1] in the valley, [2] gauge stations, [3] on the mountain", alias="categoryId")
    code: Optional[StrictStr] = None
    id: Optional[StrictStr] = None
    dd: Optional[StrictStr] = Field(default=None, description="Wind direction")
    ff: Optional[StrictStr] = Field(default=None, description="Wind speed (km/h)")
    hs: Optional[StrictStr] = Field(default=None, description="Snow depth (cm)")
    last_updated: Optional[datetime] = Field(default=None, alias="lastUpdated")
    latitude: Optional[Union[StrictFloat, StrictInt]] = None
    longitude: Optional[Union[StrictFloat, StrictInt]] = None
    lwd_type: Optional[StrictStr] = Field(default=None, description="Only for weather stations on the mountain: [1] if the weather station is a snow measuring field, [2] if the weather station is a wind station, [null] otherwise", alias="lwdType")
    n: Optional[StrictStr] = Field(default=None, description="Precipitation from midnight (mm)")
    name: Optional[StrictStr] = None
    p: Optional[StrictStr] = Field(default=None, description="Atmospheric pressure (hPa)")
    q: Optional[StrictStr] = Field(default=None, description="Flow rate (m³/s)")
    rh: Optional[StrictStr] = Field(default=None, description="Relative humidity (rH)")
    t: Optional[StrictStr] = Field(default=None, description="Air temperature (°C)")
    vaxcode: Optional[StrictStr] = None
    w: Optional[StrictStr] = Field(default=None, description="Water level (cm)")
    w_max: Optional[StrictStr] = Field(default=None, description="Wind gust", alias="wMax")
    sd: Optional[StrictStr] = Field(default=None, description="Sunshine duration (h)")
    gs: Optional[StrictStr] = Field(default=None, description="Global radiation")
    wt: Optional[StrictStr] = Field(default=None, description="Water temperature (°C)")
    visibility: Optional[StrictStr] = None
    zoom_level: Optional[StrictStr] = Field(default=None, alias="zoomLevel")
    measurements: Optional[List[RealTimeMeasurements]] = None
    __properties: ClassVar[List[str]] = ["Id", "altitude", "categoryId", "code", "id", "dd", "ff", "hs", "lastUpdated", "latitude", "longitude", "lwdType", "n", "name", "p", "q", "rh", "t", "vaxcode", "w", "wMax", "sd", "gs", "wt", "visibility", "zoomLevel", "measurements"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of WeatherRealTime from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in measurements (list)
        _items = []
        if self.measurements:
            for _item in self.measurements:
                if _item:
                    _items.append(_item.to_dict())
            _dict['measurements'] = _items
        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['Id'] = None

        # set to None if code (nullable) is None
        # and model_fields_set contains the field
        if self.code is None and "code" in self.model_fields_set:
            _dict['code'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if dd (nullable) is None
        # and model_fields_set contains the field
        if self.dd is None and "dd" in self.model_fields_set:
            _dict['dd'] = None

        # set to None if ff (nullable) is None
        # and model_fields_set contains the field
        if self.ff is None and "ff" in self.model_fields_set:
            _dict['ff'] = None

        # set to None if hs (nullable) is None
        # and model_fields_set contains the field
        if self.hs is None and "hs" in self.model_fields_set:
            _dict['hs'] = None

        # set to None if latitude (nullable) is None
        # and model_fields_set contains the field
        if self.latitude is None and "latitude" in self.model_fields_set:
            _dict['latitude'] = None

        # set to None if longitude (nullable) is None
        # and model_fields_set contains the field
        if self.longitude is None and "longitude" in self.model_fields_set:
            _dict['longitude'] = None

        # set to None if lwd_type (nullable) is None
        # and model_fields_set contains the field
        if self.lwd_type is None and "lwd_type" in self.model_fields_set:
            _dict['lwdType'] = None

        # set to None if n (nullable) is None
        # and model_fields_set contains the field
        if self.n is None and "n" in self.model_fields_set:
            _dict['n'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if p (nullable) is None
        # and model_fields_set contains the field
        if self.p is None and "p" in self.model_fields_set:
            _dict['p'] = None

        # set to None if q (nullable) is None
        # and model_fields_set contains the field
        if self.q is None and "q" in self.model_fields_set:
            _dict['q'] = None

        # set to None if rh (nullable) is None
        # and model_fields_set contains the field
        if self.rh is None and "rh" in self.model_fields_set:
            _dict['rh'] = None

        # set to None if t (nullable) is None
        # and model_fields_set contains the field
        if self.t is None and "t" in self.model_fields_set:
            _dict['t'] = None

        # set to None if vaxcode (nullable) is None
        # and model_fields_set contains the field
        if self.vaxcode is None and "vaxcode" in self.model_fields_set:
            _dict['vaxcode'] = None

        # set to None if w (nullable) is None
        # and model_fields_set contains the field
        if self.w is None and "w" in self.model_fields_set:
            _dict['w'] = None

        # set to None if w_max (nullable) is None
        # and model_fields_set contains the field
        if self.w_max is None and "w_max" in self.model_fields_set:
            _dict['wMax'] = None

        # set to None if sd (nullable) is None
        # and model_fields_set contains the field
        if self.sd is None and "sd" in self.model_fields_set:
            _dict['sd'] = None

        # set to None if gs (nullable) is None
        # and model_fields_set contains the field
        if self.gs is None and "gs" in self.model_fields_set:
            _dict['gs'] = None

        # set to None if wt (nullable) is None
        # and model_fields_set contains the field
        if self.wt is None and "wt" in self.model_fields_set:
            _dict['wt'] = None

        # set to None if visibility (nullable) is None
        # and model_fields_set contains the field
        if self.visibility is None and "visibility" in self.model_fields_set:
            _dict['visibility'] = None

        # set to None if zoom_level (nullable) is None
        # and model_fields_set contains the field
        if self.zoom_level is None and "zoom_level" in self.model_fields_set:
            _dict['zoomLevel'] = None

        # set to None if measurements (nullable) is None
        # and model_fields_set contains the field
        if self.measurements is None and "measurements" in self.model_fields_set:
            _dict['measurements'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of WeatherRealTime from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "Id": obj.get("Id"),
            "altitude": obj.get("altitude"),
            "categoryId": obj.get("categoryId"),
            "code": obj.get("code"),
            "id": obj.get("id"),
            "dd": obj.get("dd"),
            "ff": obj.get("ff"),
            "hs": obj.get("hs"),
            "lastUpdated": obj.get("lastUpdated"),
            "latitude": obj.get("latitude"),
            "longitude": obj.get("longitude"),
            "lwdType": obj.get("lwdType"),
            "n": obj.get("n"),
            "name": obj.get("name"),
            "p": obj.get("p"),
            "q": obj.get("q"),
            "rh": obj.get("rh"),
            "t": obj.get("t"),
            "vaxcode": obj.get("vaxcode"),
            "w": obj.get("w"),
            "wMax": obj.get("wMax"),
            "sd": obj.get("sd"),
            "gs": obj.get("gs"),
            "wt": obj.get("wt"),
            "visibility": obj.get("visibility"),
            "zoomLevel": obj.get("zoomLevel"),
            "measurements": [RealTimeMeasurements.from_dict(_item) for _item in obj.get("measurements")] if obj.get("measurements") is not None else None
        })
        return _obj


