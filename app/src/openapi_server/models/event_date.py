# coding: utf-8

"""
    Open Data Hub Tourism Api

    Open Data Hub Tourism Api based on .Net Core with PostgreSQL

    The version of the OpenAPI document: v1
    Contact: help@opendatahub.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json




from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_server.models.event_date_additional_info import EventDateAdditionalInfo
from openapi_server.models.event_date_calculated_day import EventDateCalculatedDay
from openapi_server.models.event_date_ticket_info import EventDateTicketInfo
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class EventDate(BaseModel):
    """
    EventDate
    """ # noqa: E501
    event_date_id: Optional[StrictStr] = Field(default=None, alias="EventDateId")
    day_rid: Optional[StrictStr] = Field(default=None, description="Deprecated use EventDateId", alias="DayRID")
    event_calculated_day: Optional[EventDateCalculatedDay] = Field(default=None, alias="EventCalculatedDay")
    event_calculated_days: Optional[List[EventDateCalculatedDay]] = Field(default=None, alias="EventCalculatedDays")
    event_date_additional_info: Optional[Dict[str, EventDateAdditionalInfo]] = Field(default=None, alias="EventDateAdditionalInfo")
    price_from: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="refers to LTS field: minAmount", alias="PriceFrom")
    var_from: Optional[datetime] = Field(default=None, alias="From")
    to: Optional[datetime] = Field(default=None, alias="To")
    begin: Optional[StrictStr] = Field(default=None, alias="Begin")
    end: Optional[StrictStr] = Field(default=None, alias="End")
    entrance: Optional[StrictStr] = Field(default=None, alias="Entrance")
    active: Optional[StrictBool] = Field(default=None, alias="Active")
    single_days: Optional[StrictBool] = Field(default=None, description="refers to LTS field: isEachDayOwnEvent", alias="SingleDays")
    is_cancelled: Optional[StrictBool] = Field(default=None, alias="IsCancelled")
    is_bookable: Optional[StrictBool] = Field(default=None, alias="IsBookable")
    min_persons: Optional[StrictInt] = Field(default=None, alias="MinPersons")
    max_persons: Optional[StrictInt] = Field(default=None, alias="MaxPersons")
    event_date_ticket_info: Optional[EventDateTicketInfo] = Field(default=None, alias="EventDateTicketInfo")
    event_variant_ids: Optional[List[StrictStr]] = Field(default=None, alias="EventVariantIds")
    ticket: Optional[StrictBool] = Field(default=None, description="Deprecated", alias="Ticket")
    cancelled: Optional[StrictStr] = Field(default=None, description="Deprecated use isCancelled", alias="Cancelled")
    __properties: ClassVar[List[str]] = ["EventDateId", "DayRID", "EventCalculatedDay", "EventCalculatedDays", "EventDateAdditionalInfo", "PriceFrom", "From", "To", "Begin", "End", "Entrance", "Active", "SingleDays", "IsCancelled", "IsBookable", "MinPersons", "MaxPersons", "EventDateTicketInfo", "EventVariantIds", "Ticket", "Cancelled"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of EventDate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of event_calculated_day
        if self.event_calculated_day:
            _dict['EventCalculatedDay'] = self.event_calculated_day.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in event_calculated_days (list)
        _items = []
        if self.event_calculated_days:
            for _item in self.event_calculated_days:
                if _item:
                    _items.append(_item.to_dict())
            _dict['EventCalculatedDays'] = _items
        # override the default output from pydantic by calling `to_dict()` of each value in event_date_additional_info (dict)
        _field_dict = {}
        if self.event_date_additional_info:
            for _key in self.event_date_additional_info:
                if self.event_date_additional_info[_key]:
                    _field_dict[_key] = self.event_date_additional_info[_key].to_dict()
            _dict['EventDateAdditionalInfo'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of event_date_ticket_info
        if self.event_date_ticket_info:
            _dict['EventDateTicketInfo'] = self.event_date_ticket_info.to_dict()
        # set to None if event_date_id (nullable) is None
        # and model_fields_set contains the field
        if self.event_date_id is None and "event_date_id" in self.model_fields_set:
            _dict['EventDateId'] = None

        # set to None if day_rid (nullable) is None
        # and model_fields_set contains the field
        if self.day_rid is None and "day_rid" in self.model_fields_set:
            _dict['DayRID'] = None

        # set to None if event_calculated_days (nullable) is None
        # and model_fields_set contains the field
        if self.event_calculated_days is None and "event_calculated_days" in self.model_fields_set:
            _dict['EventCalculatedDays'] = None

        # set to None if event_date_additional_info (nullable) is None
        # and model_fields_set contains the field
        if self.event_date_additional_info is None and "event_date_additional_info" in self.model_fields_set:
            _dict['EventDateAdditionalInfo'] = None

        # set to None if price_from (nullable) is None
        # and model_fields_set contains the field
        if self.price_from is None and "price_from" in self.model_fields_set:
            _dict['PriceFrom'] = None

        # set to None if begin (nullable) is None
        # and model_fields_set contains the field
        if self.begin is None and "begin" in self.model_fields_set:
            _dict['Begin'] = None

        # set to None if end (nullable) is None
        # and model_fields_set contains the field
        if self.end is None and "end" in self.model_fields_set:
            _dict['End'] = None

        # set to None if entrance (nullable) is None
        # and model_fields_set contains the field
        if self.entrance is None and "entrance" in self.model_fields_set:
            _dict['Entrance'] = None

        # set to None if active (nullable) is None
        # and model_fields_set contains the field
        if self.active is None and "active" in self.model_fields_set:
            _dict['Active'] = None

        # set to None if single_days (nullable) is None
        # and model_fields_set contains the field
        if self.single_days is None and "single_days" in self.model_fields_set:
            _dict['SingleDays'] = None

        # set to None if is_cancelled (nullable) is None
        # and model_fields_set contains the field
        if self.is_cancelled is None and "is_cancelled" in self.model_fields_set:
            _dict['IsCancelled'] = None

        # set to None if is_bookable (nullable) is None
        # and model_fields_set contains the field
        if self.is_bookable is None and "is_bookable" in self.model_fields_set:
            _dict['IsBookable'] = None

        # set to None if min_persons (nullable) is None
        # and model_fields_set contains the field
        if self.min_persons is None and "min_persons" in self.model_fields_set:
            _dict['MinPersons'] = None

        # set to None if max_persons (nullable) is None
        # and model_fields_set contains the field
        if self.max_persons is None and "max_persons" in self.model_fields_set:
            _dict['MaxPersons'] = None

        # set to None if event_variant_ids (nullable) is None
        # and model_fields_set contains the field
        if self.event_variant_ids is None and "event_variant_ids" in self.model_fields_set:
            _dict['EventVariantIds'] = None

        # set to None if ticket (nullable) is None
        # and model_fields_set contains the field
        if self.ticket is None and "ticket" in self.model_fields_set:
            _dict['Ticket'] = None

        # set to None if cancelled (nullable) is None
        # and model_fields_set contains the field
        if self.cancelled is None and "cancelled" in self.model_fields_set:
            _dict['Cancelled'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of EventDate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "EventDateId": obj.get("EventDateId"),
            "DayRID": obj.get("DayRID"),
            "EventCalculatedDay": EventDateCalculatedDay.from_dict(obj.get("EventCalculatedDay")) if obj.get("EventCalculatedDay") is not None else None,
            "EventCalculatedDays": [EventDateCalculatedDay.from_dict(_item) for _item in obj.get("EventCalculatedDays")] if obj.get("EventCalculatedDays") is not None else None,
            "EventDateAdditionalInfo": dict(
                (_k, EventDateAdditionalInfo.from_dict(_v))
                for _k, _v in obj.get("EventDateAdditionalInfo").items()
            )
            if obj.get("EventDateAdditionalInfo") is not None
            else None,
            "PriceFrom": obj.get("PriceFrom"),
            "From": obj.get("From"),
            "To": obj.get("To"),
            "Begin": obj.get("Begin"),
            "End": obj.get("End"),
            "Entrance": obj.get("Entrance"),
            "Active": obj.get("Active"),
            "SingleDays": obj.get("SingleDays"),
            "IsCancelled": obj.get("IsCancelled"),
            "IsBookable": obj.get("IsBookable"),
            "MinPersons": obj.get("MinPersons"),
            "MaxPersons": obj.get("MaxPersons"),
            "EventDateTicketInfo": EventDateTicketInfo.from_dict(obj.get("EventDateTicketInfo")) if obj.get("EventDateTicketInfo") is not None else None,
            "EventVariantIds": obj.get("EventVariantIds"),
            "Ticket": obj.get("Ticket"),
            "Cancelled": obj.get("Cancelled")
        })
        return _obj


