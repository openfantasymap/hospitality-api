# coding: utf-8

"""
    Open Data Hub Tourism Api

    Open Data Hub Tourism Api based on .Net Core with PostgreSQL

    The version of the OpenAPI document: v1
    Contact: help@opendatahub.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json




from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_server.models.echarging_carparking_area import EchargingCarparkingArea
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class EchargingDataProperties(BaseModel):
    """
    EchargingDataProperties
    """ # noqa: E501
    capacity: Optional[StrictInt] = Field(default=None, alias="Capacity")
    state: Optional[StrictStr] = Field(default=None, description="State of the E-chargingstation", alias="State")
    payment_info: Optional[StrictStr] = Field(default=None, description="Information about Payment", alias="PaymentInfo")
    access_type: Optional[StrictStr] = Field(default=None, description="Public or private access", alias="AccessType")
    charging_pistol_types: Optional[List[StrictStr]] = Field(default=None, description="Types of the Charging Pistols", alias="ChargingPistolTypes")
    access_type_info: Optional[StrictStr] = Field(default=None, description="AccessType Information", alias="AccessTypeInfo")
    survey_date: Optional[datetime] = Field(default=None, alias="SurveyDate")
    survey_type: Optional[StrictStr] = Field(default=None, alias="SurveyType")
    survey_annotations: Optional[Dict[str, StrictStr]] = Field(default=None, alias="SurveyAnnotations")
    covered: Optional[StrictBool] = Field(default=None, alias="Covered")
    vertical_road_sign: Optional[StrictBool] = Field(default=None, alias="VerticalRoadSign")
    horizontal_floor_road_sign: Optional[StrictBool] = Field(default=None, alias="HorizontalFloorRoadSign")
    charging_station_accessible: Optional[StrictBool] = Field(default=None, description="Charging Station Accessible", alias="ChargingStationAccessible")
    display_or_card_reader_operation_height: Optional[StrictInt] = Field(default=None, description="Maximum operation height in cm", alias="DisplayOrCardReaderOperationHeight")
    charging_pistol_operation_height: Optional[StrictInt] = Field(default=None, description="Maximum operation height in cm (barrierfree = 90-120 cm)", alias="ChargingPistolOperationHeight")
    charging_cable_length: Optional[StrictInt] = Field(default=None, alias="ChargingCableLength")
    shielding_post_in_front_of_station: Optional[StrictBool] = Field(default=None, alias="ShieldingPostInFrontOfStation")
    stepless_sidewalk_connection: Optional[StrictBool] = Field(default=None, description="Stufenlose Gehsteiganbindung: zulässige maximale Steigung <5-8%) bodengleich an den Gehsteig angebunden", alias="SteplessSidewalkConnection")
    barrierfree: Optional[StrictStr] = Field(default=None, alias="Barrierfree")
    car_parking_space_next_to_each_other: Optional[EchargingCarparkingArea] = Field(default=None, alias="CarParkingSpaceNextToEachOther")
    car_parking_space_behind_each_other: Optional[EchargingCarparkingArea] = Field(default=None, alias="CarParkingSpaceBehindEachOther")
    __properties: ClassVar[List[str]] = ["Capacity", "State", "PaymentInfo", "AccessType", "ChargingPistolTypes", "AccessTypeInfo", "SurveyDate", "SurveyType", "SurveyAnnotations", "Covered", "VerticalRoadSign", "HorizontalFloorRoadSign", "ChargingStationAccessible", "DisplayOrCardReaderOperationHeight", "ChargingPistolOperationHeight", "ChargingCableLength", "ShieldingPostInFrontOfStation", "SteplessSidewalkConnection", "Barrierfree", "CarParkingSpaceNextToEachOther", "CarParkingSpaceBehindEachOther"]

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('UNAVAILABLE', 'ACTIVE', 'TEMPORARYUNAVAILABLE', 'AVAILABLE', 'UNKNOWN', 'FAULT', 'PLANNED',):
            raise ValueError("must be one of enum values ('UNAVAILABLE', 'ACTIVE', 'TEMPORARYUNAVAILABLE', 'AVAILABLE', 'UNKNOWN', 'FAULT', 'PLANNED')")
        return value

    @field_validator('access_type')
    def access_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('PUBLIC', 'PRIVATE', 'PRIVATE_WITHPUBLICACCESS',):
            raise ValueError("must be one of enum values ('PUBLIC', 'PRIVATE', 'PRIVATE_WITHPUBLICACCESS')")
        return value

    @field_validator('charging_pistol_types')
    def charging_pistol_types_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in ():
                raise ValueError("each list item must be one of ()")
        return value

    @field_validator('barrierfree')
    def barrierfree_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('Barrierefrei', 'Bedingt zugänglich', 'Nicht zugänglich',):
            raise ValueError("must be one of enum values ('Barrierefrei', 'Bedingt zugänglich', 'Nicht zugänglich')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of EchargingDataProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
                "state",
                "payment_info",
                "access_type",
                "charging_pistol_types",
                "access_type_info",
                "charging_station_accessible",
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of car_parking_space_next_to_each_other
        if self.car_parking_space_next_to_each_other:
            _dict['CarParkingSpaceNextToEachOther'] = self.car_parking_space_next_to_each_other.to_dict()
        # override the default output from pydantic by calling `to_dict()` of car_parking_space_behind_each_other
        if self.car_parking_space_behind_each_other:
            _dict['CarParkingSpaceBehindEachOther'] = self.car_parking_space_behind_each_other.to_dict()
        # set to None if capacity (nullable) is None
        # and model_fields_set contains the field
        if self.capacity is None and "capacity" in self.model_fields_set:
            _dict['Capacity'] = None

        # set to None if state (nullable) is None
        # and model_fields_set contains the field
        if self.state is None and "state" in self.model_fields_set:
            _dict['State'] = None

        # set to None if payment_info (nullable) is None
        # and model_fields_set contains the field
        if self.payment_info is None and "payment_info" in self.model_fields_set:
            _dict['PaymentInfo'] = None

        # set to None if access_type (nullable) is None
        # and model_fields_set contains the field
        if self.access_type is None and "access_type" in self.model_fields_set:
            _dict['AccessType'] = None

        # set to None if charging_pistol_types (nullable) is None
        # and model_fields_set contains the field
        if self.charging_pistol_types is None and "charging_pistol_types" in self.model_fields_set:
            _dict['ChargingPistolTypes'] = None

        # set to None if access_type_info (nullable) is None
        # and model_fields_set contains the field
        if self.access_type_info is None and "access_type_info" in self.model_fields_set:
            _dict['AccessTypeInfo'] = None

        # set to None if survey_date (nullable) is None
        # and model_fields_set contains the field
        if self.survey_date is None and "survey_date" in self.model_fields_set:
            _dict['SurveyDate'] = None

        # set to None if survey_type (nullable) is None
        # and model_fields_set contains the field
        if self.survey_type is None and "survey_type" in self.model_fields_set:
            _dict['SurveyType'] = None

        # set to None if survey_annotations (nullable) is None
        # and model_fields_set contains the field
        if self.survey_annotations is None and "survey_annotations" in self.model_fields_set:
            _dict['SurveyAnnotations'] = None

        # set to None if covered (nullable) is None
        # and model_fields_set contains the field
        if self.covered is None and "covered" in self.model_fields_set:
            _dict['Covered'] = None

        # set to None if vertical_road_sign (nullable) is None
        # and model_fields_set contains the field
        if self.vertical_road_sign is None and "vertical_road_sign" in self.model_fields_set:
            _dict['VerticalRoadSign'] = None

        # set to None if horizontal_floor_road_sign (nullable) is None
        # and model_fields_set contains the field
        if self.horizontal_floor_road_sign is None and "horizontal_floor_road_sign" in self.model_fields_set:
            _dict['HorizontalFloorRoadSign'] = None

        # set to None if charging_station_accessible (nullable) is None
        # and model_fields_set contains the field
        if self.charging_station_accessible is None and "charging_station_accessible" in self.model_fields_set:
            _dict['ChargingStationAccessible'] = None

        # set to None if display_or_card_reader_operation_height (nullable) is None
        # and model_fields_set contains the field
        if self.display_or_card_reader_operation_height is None and "display_or_card_reader_operation_height" in self.model_fields_set:
            _dict['DisplayOrCardReaderOperationHeight'] = None

        # set to None if charging_pistol_operation_height (nullable) is None
        # and model_fields_set contains the field
        if self.charging_pistol_operation_height is None and "charging_pistol_operation_height" in self.model_fields_set:
            _dict['ChargingPistolOperationHeight'] = None

        # set to None if charging_cable_length (nullable) is None
        # and model_fields_set contains the field
        if self.charging_cable_length is None and "charging_cable_length" in self.model_fields_set:
            _dict['ChargingCableLength'] = None

        # set to None if shielding_post_in_front_of_station (nullable) is None
        # and model_fields_set contains the field
        if self.shielding_post_in_front_of_station is None and "shielding_post_in_front_of_station" in self.model_fields_set:
            _dict['ShieldingPostInFrontOfStation'] = None

        # set to None if stepless_sidewalk_connection (nullable) is None
        # and model_fields_set contains the field
        if self.stepless_sidewalk_connection is None and "stepless_sidewalk_connection" in self.model_fields_set:
            _dict['SteplessSidewalkConnection'] = None

        # set to None if barrierfree (nullable) is None
        # and model_fields_set contains the field
        if self.barrierfree is None and "barrierfree" in self.model_fields_set:
            _dict['Barrierfree'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of EchargingDataProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "Capacity": obj.get("Capacity"),
            "State": obj.get("State"),
            "PaymentInfo": obj.get("PaymentInfo"),
            "AccessType": obj.get("AccessType"),
            "ChargingPistolTypes": obj.get("ChargingPistolTypes"),
            "AccessTypeInfo": obj.get("AccessTypeInfo"),
            "SurveyDate": obj.get("SurveyDate"),
            "SurveyType": obj.get("SurveyType"),
            "SurveyAnnotations": obj.get("SurveyAnnotations"),
            "Covered": obj.get("Covered"),
            "VerticalRoadSign": obj.get("VerticalRoadSign"),
            "HorizontalFloorRoadSign": obj.get("HorizontalFloorRoadSign"),
            "ChargingStationAccessible": obj.get("ChargingStationAccessible"),
            "DisplayOrCardReaderOperationHeight": obj.get("DisplayOrCardReaderOperationHeight"),
            "ChargingPistolOperationHeight": obj.get("ChargingPistolOperationHeight"),
            "ChargingCableLength": obj.get("ChargingCableLength"),
            "ShieldingPostInFrontOfStation": obj.get("ShieldingPostInFrontOfStation"),
            "SteplessSidewalkConnection": obj.get("SteplessSidewalkConnection"),
            "Barrierfree": obj.get("Barrierfree"),
            "CarParkingSpaceNextToEachOther": EchargingCarparkingArea.from_dict(obj.get("CarParkingSpaceNextToEachOther")) if obj.get("CarParkingSpaceNextToEachOther") is not None else None,
            "CarParkingSpaceBehindEachOther": EchargingCarparkingArea.from_dict(obj.get("CarParkingSpaceBehindEachOther")) if obj.get("CarParkingSpaceBehindEachOther") is not None else None
        })
        return _obj


